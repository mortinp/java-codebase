Actualmente el DAO (version mejorada en core) tiene un servicio de busqueda, que dada la sentencia sql, la ejecuta y devuelve un result set. Lo que sucede con esto es que el objeto que quiera usar el result set en realidad no lo puede usar, pues el mismo esta cerrado. Como resolver este problema???.

FUNDAMENTOS: Si retornamos el result set mediante un servicio, tenemos que garantizar que el prepared statement que lo crea no este cerrado para que el result set se pueda usar. Pero para esto, tendriamos que delegar el control del cierre del pstm a la clase que invoca el servicio de busqueda (y usa el result set). Esto trae como consecuencia que el manejo de algunas excepciones tambien se tenga que ejecutar en la clase que invoca el servicio. Al final, estamos fallando en abstraer a la clase cliente de todas las cosas que ocurren a nivel de BD.

IDEA: creo que la mejor forma es con el patron Strategy.
OTRA IDEA (Nolvis): crear un DAO para cada consulta especifica. Lo que sucede con esto es que tendriamos que definir varios DAOs solo para definir distintas formas de construccion. Y los metodos para insertar, actualizar, eliminar, etc, como los defino???. Para que volverlos a definir si ya existe un DAO encargado de esto???. Un usuario del servicio, cual DAO escogeria para realizar las inserciones, actualizaciones y eliminaciones???

SOLUCION: Mantener la responsabilidad de mapear el resultado de una consulta a un objeto (modelo) dentro de la clase que brinda el servicio (GeneralDAO), y no en el cliente; asi, la clase que brinda el servicio puede encargarse tambien del cierre del pstm y del manejo de las excepciones, quedando la clase cliente totalmente abstraida. Actualmente esto se logra mediante un metodo hook (patron Template Method) que debe definir la clase que invoca el servicio. Pero entonces caemos en la dificultad de que solo tenemos una forma de construir el objeto, que asume la existencia de ciertas columnas de tablas de la BD en el resultado de la consulta. 
El asunto es que este servicio existe realmente para ser invocado con cualquier consulta. Por tanto, tambien debe ser pensado para mapear de diferentes formas al objeto, y que solo se pueden conocer en tiempo de ejecucion. Aparece entonces la necesiad de 'inyectarle' al objeto que define el servicio la forma de construir el objeto. El problema se reduce entonces a la sigiente pregunta: como podemos 'inyectar' la forma de construir el objeto a partir del resultado de una consulta desconocida al procedimiento que define servicio?. El patron Strategy nos puede ayudar en esto.
Tecnicamente lo que hariamos seria pasarle un parametro mas al/los metodo(s) de busqueda. Este parametro seria la estrategia de mapeo, que encapsula la forma de mapear un result set a un objeto. Si generalizamos mas esta idea, podriamos sustituir los metodos abstractos de mapeos que define GeneralDAO (crearListaResultado(ResultSet rs) y crearObjetoResultado(ResultSet rs)), por un objeto estrategia.
Esto lleva a la necesidad de que el DAO tenga una estrategia por defecto siempre, por lo cual debemos garantizar que se tenga desde el momento de la construccion. Para esto, el constructor de GeneralDAO debe recibir la estrategia inicial.
Se pueden tener metodos de busqueda que no reciban una estrategia (como el buscarTodos()), los cuales usarian la estrategia definida por defecto para el DAO.
(YA ESTO LO IMPLEMENTE EN EL CORE!!!)

IDEAS ADICIONALES: 
-Las clases clientes del servicio de busqueda aun no quedan totalmente abstraidas de la BD, pues aun manipulan objetos de tipo ResultSet. Debido a esto, tambien heredan las consecuencias de la manipulacion de estos, como el manejo de las excepciones que se pueden generar al leer o recorrer el result set, etc. Una abstraccion total significaria que la clase cliente ni siquiera sepa la forma en que se recuperan los datos. O sea, no tiene por que saber si se usa JDBC u otro framework/libreria de acceso a datos.
Una forma de abstraer al cliente de los result sets seria implementando una clase propia que contenga los mismos resultados que un result set, y que provea alguna forma de iterar sobre este, y que a la vez maneje todas las excepciones. El cliente debe lograr una abstraccion de  tal forma que solo le parezca que enviando la consulta, obtiene un objeto que puede mapear hacia un objeto del dominio.
Como se usaria mas o menos este tipo de objeto???:

while(contenedor.next()) {
	int a = (int) contenedor.getObjeto("columna_int");
	float b = (float) contenedor.getObjeto("columna_float");
	Date c = (Date) contenedor.getObjeto("columna_date");	
}

Lo malo de este enfoque son los casteos que hay que hacer. Se podrian tener metodos de la forma getDate() o getString() que envuelvan los de los result sets, pero habria que actualizar esta clase contenedor cada vez que se actualice la clase ResultSet.

NOTA: En vez de llamarse GeneralDAO deberia llamarse JDBCDAO (?). Lo malo de esto es que al heredar de este, ya se sabe la forma en que se obtienen los datos. Un nombre hace fallar la abstraccion (leaky abstraction)!!!.

-Seria mejor tener tanto las consultas como la forma de mapear los objetos dentro de las estrategias de mapeo???. Si se tienen ambas cosas, el trabajo de construir la capa de acceso a datos consistiria en gran medida en definir todas las estrategias de mapeo con sus consultas. Se podrian definir todas las estrategias con sus consultas primero, y luego usarlas en la clase que usa los servicios de acceso a datos (las que heredan de GeneralDAO).
Una estrategia de mapeo seria en realidad un paquete que encapsularia toda la funcionalidad de una busqueda en la BD. Todas las busquedas se encapsularian dentro de objetos estrategias de mapeo. O se le puede poner otro nombre a esta clase.
Valorar esto!!!
