-------------------SOBRE EL CARGADO DE REFERENCIAS A OTROS OBJETOS----------------

Supongamos que en el mapeo podamos poner una entrada como esta:

cliente @reference(Cliente) @loadonly(codigo, descripcion): cliente_codigo

Esta entrada quiere decir que el atributo cliente se mapea con el campo cliente_codigo. Pero ademas se especifica que el atributo cliente es una referencia a Cliente (en este caso, cliente no es una clase, sino mas bien un alias, que se puede usar para encontrar sus metadatos, por ejemplo), por lo cual en realidad el campo cliente_codigo, es una llave foranea, y coge el valor de la llave del cliente. Por otro lado, se especifica ademas que a la hora de cargar el cliente, solamente se deben cargar sus atributos codigo y descripcion (en realidad la especificacion del atributo codigo es redundante pues la llave es obligado cargarla siempre: mandatory field).

Esto da la idea de que debe haber un nivel de acceso a los metadatos de las clases que no sea solamente a nivel de clase, sino a un nivel mayor, para poder encontrar, en el caso del ejemplo, los metadatos del cliente.

La idea que se me estaba ocurriendo era la de que haya alguna entidad global que se encargue de formar alguna jerarquia de mappers. La explicacion de esto es la siguiente:

Supongamos que desde un DAO queremos realizar operaciones sobre algun objeto, usando los metadatos que se definieron para la clase de dicho objeto a traves de un MappingBuilder (ej. el simpleMetadataMapperDAO es un ejemplo de esto). Es evidente que si los metadatos de este objeto definen referencias a otros objetos, entonces hacen falta los MappingBuilders de estas referencias. Y si alguna de estas referencias tiene en sus metadatos otras referencias, entonces tambien hacen falta los MappingBuilders de estas. Asi, lo que se forma es una jerarquia de MappingBuilders, la cual se podria implementar con el patron Composite. Para construir esta jerarquia hace falta algun objeto que tenga esta responsabilidad, y que este a un nivel superior a los MappingBuilder; un objeto que sea capaz de inspeccionar los metadatos de una clase, y si se encuentran referencias a otras, encontrar los respectivos metadatos, y armar la jerarquia.

Lo que se crearia entonces seria una jerarquia de MappingBuilders. Esta jerarquia se usaria entonces para el cargado y modificacion de los datos en algun mecanismo de persistencia (BD, XML, archivos de texto, etc.).

Ideas para la implementacion:


Otras Ideas:

-Los campos de tipo @reference se podrian tratar como @noupdate por defecto.


UPDATE (19-07-2012): Estaba pensando que se podria tener un MirrorMapper. Esta clase se encargaria de hacer todo el trabajo de cargar una referencia de un objeto (para ponerselo a otro) y de retornar los mapas de insercion y actualizacion, pero en base a la tabla del objeto contenedor, no del objeto contenido. Esto quiere decir que si creamos un MirrorMapper para mapear un cliente que va a tener una referencia en otro objeto, entonces este MirrorMapper hace los mapeos basados en los metadatos del objeto contenedor, tanto para obtener el cliente a partir de la tabla del objeto contenedor, como para insertar o modificar en la tabla del objeto contenedor. O sea, el MirrorMapper conoceria los nombres de los campos que referencian al cliente en la otra tabla a traves de las entries (esto necesita de otro objeto para que construya las entries).

Lo otro que se puede hacer es crear un MappingBuilder pero ponerle las entries con los datos que hacen falta para que los mapeos sean con respecto al objeto contenedor.

----------------------------------------------------------------------------------